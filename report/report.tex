\documentclass[9pt,oneside]{amsart}

\title{Symbolic repetability verification algorithm}
\author{
  Luca Zaninotto mat. 2057074 
  \and
  Davide Farinelli mat.2005758
  \and
  Matteo Budai mat. 2057217
}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{tikz}
\usepackage[a4paper,width=170mm,top=10mm,bottom=22mm,includeheadfoot]{geometry}

\hypersetup{
 pdfauthor={Luca Zaninotto},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={Monitor to check the fairness of the railroad system},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\begin{abstract}
  Algorithm for invariant verification in a finite state model through
  symbolic representation of regions, using pynusmv to encode and
  model the system itself
\end{abstract}
\maketitle
\setlength{\columnsep}{20pt}
\begin{multicols}{2}
  \section{The algorithm}\label{algo}
  The algorithm we developed works in two parts. Given a set of
  states, a transition system and a temporal logic invariant in the
  shape of
  \[
    \square \diamondsuit f \rightarrow \square \diamondsuit g
  \]
  first it discovers weather the LTL formula is respected or not, then,
  if the LTL formula is not respected provides a counterexample.
  \section{region exploration}\label{explore}
  The algorithm used to verify the LTL formula is the following.
  \begin{lstlisting}[language=Python]
  	def research(fsm, f, g):
  	reach = fsm.init
  	new = fsm.init
  	while fsm.count_states(new) > 0:
  	new = fsm.post(new) - reach
  	reach = reach + new
  	recur = reach & f & (~g)
  	while fsm.count_states(recur) > 0:
  	new = fsm.pre(recur) & (~g)
  	reach = new
  	while fsm.count_states(new) > 0:
  	reach = reach + new
  	if recur.entailed(reach):
  	return False, gen_counterex(fsm, f, g, reach)
  	new = (fsm.pre(new) - reach) & (~g)
  	recur = recur & reach
  	return True, None
  \end{lstlisting}\label{code:reachable}
	In this function we initialize the reachable states (for the first step just the
	set of initital states) and the newly found states (again,
	for the first iteration the set of initial states).

	\section{Generating a counterexample}\label{back}
	To generate a counterexample we use the following function.
	\begin{lstlisting}[language=Python]
		def gen_counterex(fsm, f, g, reach):
		states = []
		while fsm.count_states(reach):
		state = fsm.pick_one_state(reach)
		states.append(state)
		reach = reach - state
		last_state = states[-1]
		states.reverse()
		states.append(last_state)
		counterex = ()
		for (s1, s2) in zip(states, states[1:]):
		inputs = fsm.get_inputs_between_states(s1, s2)
		if inputs != pynusmv.dd.BDD.false():
		inputt = fsm.pick_one_inputs(inputs)
		counterex += (s1.get_str_values(), inputt.get_str_values())
		else:
		counterex += (s1.get_str_values(), {})
		counterex += (states[-1].get_str_values(), )
		return counterex
	\end{lstlisting}
	In this function we reverse the list of states because when searching for the cycling execution we have used the pre-image calculation, exploring the states backwards respect the normal execution flow.
\end{multicols}
\end{document}
