\documentclass[9pt,oneside]{amsart}

\title{Symbolic repetability verification algorithm}
\author{
  Luca Zaninotto mat. 2057074 
  \and
  Davide Farinelli mat.2005758
  \and
  Matteo Budai mat. 2057217
}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{tikz}
\usepackage[a4paper,width=170mm,top=10mm,bottom=22mm,includeheadfoot]{geometry}

\hypersetup{
 pdfauthor={Luca Zaninotto},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={Monitor to check the fairness of the railroad system},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\begin{abstract}
  Algorithm for invariant verification in a finite state model through
  symbolic representation of regions, using pynusmv to encode and
  model the system itself
\end{abstract}
\maketitle
\setlength{\columnsep}{20pt}
\begin{multicols}{2}
\section{The algorithm}\label{algo}
The algorithm we used to verify invariants in a finite state model is
composed of two parts. The first part checks whether the invariant is
respected or not; the second one, if the invariant is not respected
provides a counterexample. The first part is a variant of the region
exploration algorithm, the only difference is that instead of returning
the set of reachable nodes, it returns the list of newly explored nodes,
to allow the explanation algorithm to get a counterexample in a number
of steps that is less than the number of newly explored regions to check
the validity of the invariant.

\section{region exploration}\label{explore}
The algorithm used to explore the regions is the following.
\begin{lstlisting}[language=Python]
def research(fsm, bddspec):
  reach = fsm.init
  new = fsm.init
  sequence = []
  while fsm.count_states(new) > 0:
      notResp = new - bddspec
      if fsm.count_states(notResp) > 0:
          return fsm.pick_one_state_random(notResp), sequence
      sequence.append(new)
      new = fsm.post(new) - reach
      reach = reach + new
  return None, sequence
\end{lstlisting}\label{code:reachable}
Through pynusmv we can get the model described in a nusmv file, load it
and access it through the \texttt{fsm} module. We initialize the
reachable states (for the first step just the set of initital states)
and the newly found states (again, for the first iteration the set of
initial states). Sequence instead is the sequence of newly visited
nodes. It is initialized as the empty list since at first there are no
new nodes apart from the initial set. \texttt{bddspec} is the set of
states in the system that satisfies the invariant, so by taking the
difference between the new states and the bddspec we find a sybolic
formula that identifies the nodes that do not satisfy the invariant
between the new nodes. If this set (\texttt{notResp}) is not empty we
are done, we can just return one node contained in it and the sequence.
Otherwise we update the sequence (we do this after checking
whether a node invalidates the invariant so that when we go back to the
first iteration, works, more on that on \S\ref{back}) with the checked
nodes and compute new nodes with the post image of new nodes,
remembering to remove already reached nodes; this is both to explore
unexplored regions and to avoid cycles in the sequence. In fact, each
node can appear only once in some set of the sequence. It cannot
appear in a set after the one in which it appeared for the first time
in the sequence. If at some point we have no more states to reach and
the invariant still holds for all the sets, then it means it holds for
all reachable nodes, therefore the system respects it and we return \textit{None}.

\section{Generating a counterexample}\label{back}
To generate a counterexample we start from the list generated by
\S\ref{code:reachable} and the provided node.
\begin{lstlisting}[language=Python]
def go_back(fsm, node, sequence):
  current = node
  init = fsm.init
  path = current,
  it = 1
  while (current * init).is_false():
      parent_region = sequence[-it] & fsm.pre(current)
      parent = fsm.pick_one_state(parent_region)
      path = compute_path(fsm, parent, current) + path
      current = parent
      it += 1
  return path
\end{lstlisting}
We first initialize the current node to the given node (the one that
does not respect the invariant), the path to a tuple containing just
the node and a counter to 1. Then, for each \texttt{current} node we
first check whether it is in the set of inital states or not. If
that's the case we are done, the path contains a real path from an
initial state to a state that invalidates the invariant. Otherwise we
enter in the loop:
\begin{enumerate}
\item we compute the region of valid parent states: states that are
  both in the pre-image of the current node and in the set of newly
  nodes stored in the sequence (iterating backwards in it since each
  time the new set is appended).
\item We pick one state in the set. We can make this choice randomly,
  since for a state to be in this parent set it needs to be both
  reachable (that means there's a path from it to a node in the set of
  initial states) and \textit{direct}, that is to say that there are
  no cycles in a path from that state to one in the initial set (this
  is for construction of the sequence).
\item With an helper function compute the path from the parent to the
  current node and append it to the path (the helper function just
  returns a tuple of the parent state and an input that from the
  parent node allows to go to the current state).
\item Finally update the current node to the parent node and growing
  the iteration number.
\end{enumerate}
The path returned is a tuple containing, one after the other, a state
and an input to go to the next state, where the first state is in the
set of initial states, and the last one is a state where the
considered invariant is not respected.
\end{multicols}
\end{document}
